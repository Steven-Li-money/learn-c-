### 一、多态是如何实现的？这个基本上是各个公司必问的问题。在回答这个问题的时候不能仅仅说虚表，必须要了解虚表具体是怎么实现的，比如一个类如果有虚函数那么其实例化的对象前8（或4）字节会是虚表指针的地址，后面才是成员变量。然后通过这个还需要了解一些动态绑定、函数存储和虚函数存储的位置等等。回答的越细致越好。
#### 1、通过基类指针调用基类和派生类中同名的虚函数时，若该指针指向一个基类的对象，那么被调用是 基类的虚函数；若该指针指向一个派生类的对象，那么被调用 的是派生类的虚函数。这就是多态。
#### 2、64位的电脑中，有虚函数类的对象中的前8位是一个<指向虚函数表>的指针，后面才有成员变量之类的
#### 3、当然多态还分运行期多态和编译期多态，运行期多态有继承和虚函数两种表现，编译期多态有重载和模板
#### 4、还有就是虚析构函数和虚构造函数的问题，注意没有虚构造，只有虚析构！在使用基类指针指向派生类的时候，当delete的时候，如果基类的析构函数没有声明virual时，便不会调用子类的析构，会造成资源泄露，因此需要将基类的析构函数声明位virual，这个过程中依然遵循<先构造后析构>!

### 二、c++内存管理以及如何防止内存泄漏？这部分好像是主管面比较喜欢面的。首先是可以使用智能指针比如shared_ptr自动进行内存的引用计数和释放，其次是可以使用内存池，关于内存池是一个比较复杂的东西、可以完整的去找相关的资料学习。主要就是可以重载operator new来接管其中内存分配的部分（申请一大块的内存，将其划分位等大小的block再返回相应的地址）。我们知道new跟malloc是有区别的、主要是new会自动调用类构造函数。这边重载的operator new负责的是内存分配的那部分，构造函数还是会自动调用的。
#### c++的内存分配方式有堆、栈、自由存储区、全局/静态存储区、常量存储区
#### 内存泄露的检测方法和解决办法
##### 1、使用智能指针自动管理内存的释放
##### 2、使用内存池，一个方法是重载operator new来分配内存，申请一大块的内存，将其划分位等大小的block再返回相应的地址，进行内存池管理，其中内存池的特性有
###### （1）预先分配固定大小的内存块，内存池会预先分配一些固定大小的内存块,当程序需要内存时直接从内存池中获取,不需要进行动态内存分配。使用完成后将内存块返回给内存池进行复用,而不是释放内存。这样可以避免频繁的内存分配和释放。
###### （2）重用内存块，程序用完内存后,内存块不会被释放,而是放回内存池,供其他程序复用。这避免了内存的释放,从而避免了潜在的内存泄露。
###### （3）定期释放未使用的内存，内存池可以定期检查每个内存块的使用情况,将长时间未使用的内存块释放,腾出空间供新程序使用,避免内存占用过多。
###### （4）更精确的内存跟踪，内存池可以更精确地跟踪每个内存块的分配情况,如线程、时间等, thus能更容易地定位内存泄露。
##### 关于new和delete和malloc和free的区别
###### 首先new包含两阶段的操作：分配空间、初始化对象、返回指针
###### （1）首先调用：：operator new分配内存 （2）调用Foo::Foo() 构造对象内容，然后是delete也分两部分的操作。
###### （2）首先调用Foo::~Foo()将对象析构 （2）调用::operator delete释放内存，那么可以对::operator new和::operator delete进行重载么，当然是肯定的
##### 3、vs中查看内存泄露的工具是CRT库，在代码末尾加上_CrtDumpMemoryLeaks();

### 三、智能指针相关问题？这部分其实比较八股、很多的面经都有提到，主要是可以看看shared_ptr如何实现的、以及线程安全这部分（包括如何保证线程安全）。
#### 三大智能指针
##### 线程安全：通常，你可以依赖于std::shared_ptr的线程安全性，或者使用额外的同步机制。
##### std::shared_ptr本身的操作（如复制和销毁）是线程安全的：你可以在不同的线程中安全地复制和销毁std::shared_ptr，而不需要额外的同步机制。这是因为std::shared_ptr内部使用了原子操作来增加和减少引用计数。
##### 通过std::shared_ptr访问和修改所指向的对象的操作并不是线程安全的：如果你在多个线程中使用同一个std::shared_ptr来访问和修改同一个对象，你需要使用额外的同步机制（如互斥量或锁）来保证操作的线程安全性。
##### 改变std::shared_ptr所指向的对象（即，使std::shared_ptr指向另一个对象）并不是线程安全的：如果你在一个线程中改变std::shared_ptr所指向的对象，而另一个线程正在使用std::shared_ptr，那么你需要使用额外的同步机制来保证操作的线程安全性。

### 四、单例模式的作用以及实现？这个其实很多公司问了，一定要掌握。
#### 单例模式（Singleton Pattern）是一种设计模式，主要用来限制一个类只能有一个实例，并提供一个全局访问点。
```C++
class Singleton {
private:
  static Singleton* instance; 
  Singleton() {}
public:
  static Singleton* getInstance() {
  if (instance == nullptr) {
    instance = new Singleton();
  }
  return instance;
  }
};
Singleton* Singleton::instance = nullptr;
int main() {
  Singleton* s1 = Singleton::getInstance();
  Singleton* s2 = Singleton::getInstance();
  if (s1 == s2) {
  cout << "Same instance!" << endl; 
  }
  return 0;
}
```
#### 主要逻辑:
##### 构造函数私有化,不允许外部直接创建实例。
##### 提供一个静态的getInstance()方法来获取单例实例。
##### 静态变量instance用于保存单例实例。
##### getInstance()方法判断instance是否已初始化,如果未初始化则创建实例并保存。
##### 每次调用getInstance()返回的都是同一个实例。
##### 这样通过 getInstance() 获取的 Singleton 实例就保证了全局唯一。

### 五、static的用法类型？很多知识点其实是相互关联的比如在单例模式中使用了staitc关键字，这种时候就可以顺便去差一些各种static的用法，包括函数内、类成员变量、类函数等，一定要把知识点串起来。关于static可能还会问这个问题：因为cpp文件中的static函数会保证其只在当前cpp文件中可见，这是如何实现的?这个的话就需要看一些编译链接的东西了。建议掌握
#### 在C++中，static关键字有多个用途，具体取决于它在哪里使用：
##### 1. 静态局部变量：在函数内部，static关键字可以用来声明静态局部变量。一个静态局部变量在函数首次调用时初始化，然后在后续的函数调用中保持其值，直到程序结束时才被销毁。例如：
```C++
void func() {
  static int i = 0;
  i++;
  std::cout << i << std::endl;
}
```
###### 在这个例子中，每次调用func()，i都会增加1，而不是被重新初始化为0。
##### 2. 静态类成员变量：在类中，static关键字可以用来声明静态成员变量。无论创建了多少个类的对象，静态成员变量只有一份拷贝。并且，静态成员变量在类外初始化。
```C++
class MyClass {
public:
  static int my_static;
};
int MyClass::my_static = 0;
```
##### 3. 静态类成员函数：在类中，static关键字也可以用来声明静态成员函数。静态成员函数可以直接通过类来调用，而无需创建对象，因为它不依赖于任何类的对象。静态成员函数只能访问静态成员变量，不能访问类的非静态成员变量。
```C++
class MyClass {
public:
  static void my_static_func() {
    std::cout << "This is a static function.\n";
  }
};
```
##### 4. 静态全局变量和函数：在一个文件中，static关键字可以用来限制全局变量和函数的可见性。只有在声明它们的文件中，才能访问这些静态全局变量和函数。在文件范围之外，它们是不可见的。
```C++
static int my_static_var = 0;
static void my_static_func() {
  std::cout << "This is a static function.\n";
}
```
#### 这种限制的实现是在编译和链接过程中进行的。在编译时，编译器会为每个文件生成一个符号表，其中包含了该文件中定义的所有全局变量和函数的名称。如果一个变量或函数被声明为static，那么编译器就不会将其名称添加到符号表中。因此，在链接时，其他文件无法找到这个static变量或函数的名称，也就无法使用它

